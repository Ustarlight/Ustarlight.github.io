---
layout: post
title:  "2023-11-08-some-review-about-vision--2D-Object-Detection-Anchor-based-One-Stage-SSD"
date:   2023-11-08 15:42:45 +0800
categories: share
---

SSD属于基于锚框的物体检测中的单阶段法，Faster R-CNN属于经典的两阶段法检测网络，首先通过RPN得到若干候选区域，再对候选区域进行多分类和回归得到最终的检测结果，如下图所示。

![](./2023-11-08-some-review-about-vision--2D-Object-Detection-Anchor-based-One-Stage-SSD/截屏2023-11-08 15.43.23.png)

先回顾一下Faster R-CNN中RPN的步骤：

1. 整张图传入VGG16或ResNet得到一系列经过下采样后的特征图；
2. 选择下采样倍数为16的特征层作为检测层；
3. 在检测层铺设一系列大小和比例的锚框（9个）；
4. 对锚框进行二分类和回归得到若干候选区域。

得到若干候选区域后，对每个候选区域进行如下操作：

1. 利用RoIPooling在检测层的特征上提取每个候选区域对应的特征；
2. 输入CNN/FC子网络对候选区域的特征进行增强；
3. 对增强后的候选区域特征进行多分类和位置矫正得到最终检测结果。

单阶段物体检测算法就是把Faster R-CNN的RPN步骤中的第4步“对锚框进行**二分类**和**回归**得到**若干候选区域**”更改为“对锚框进行**多分类**和**位置矫正**得到**最终检测结果**”，基于锚框的单阶段检测算法的集大成者包括SSD和RetinaNet，本文先介绍SSD，后续再对RetinaNet进行介绍。

**SSD (Single Shot Multibox Detector)**

- 输入图像：经过丰富的数据增广，得到300x300或512x512的输入图像；
- 基础网络： ImageNet预训练的VGG16网络+一些额外的卷积层；
- 多检测层：选取6个不同下采样倍数的特征层（下图中已标出）作为检测层，每层关联不同尺度大小的锚框，共铺设8732个锚框；
- 难负样本挖掘：在预铺设的锚框中，大部分为负样本，只有少数是正样本，带来了“训练困难的问题”。利用误差损失值的大小（从大到小降序排列），选择出3倍正样本的负样本参与训练。

![](./2023-11-08-some-review-about-vision--2D-Object-Detection-Anchor-based-One-Stage-SSD/截屏2023-11-08 15.47.03.png)

**数据增广**

SSD中采用的数据增广相对来说是比较复杂的，具体采用的数据增广的形式如下：

- 随机颜色抖动：将输入图像的颜色、对比度、饱和度等随机调整；
- 随机裁剪：在原图上随机裁剪得到一个子图像；
- 随机扩充：生成一个尺寸大于子图像、像素值为子图像像素均值的画布，将子图像随机放在画布上的任意位置；
- 随机水平翻转：随机对放置了子图像的画布进行水平翻转；
- 图像缩放：将图像缩放到300x300的尺寸。

需要注意的是以上数据增广大部分都只在训练阶段生效，测试阶段对输入测试图像的数据增广只有图像缩放。

![](./2023-11-08-some-review-about-vision--2D-Object-Detection-Anchor-based-One-Stage-SSD/截屏2023-11-08 15.50.24.png)

**随机颜色抖动**

随机颜色抖动包含下列四种操作：

- 亮度抖动：RGB图像 + random(-32, 32)
- 对比度抖动：RGB图像 x random.uniform(0.5, 1.5)
- 饱和度抖动：HSV图像的S通道 x random.uniform(0.5, 1.5)
- 色调抖动：HSV图像的H通道 + random(-18, 18)

这里提到的随机有以下三层含义：

1. 随机颜色抖动操作包含两条设计路线（如下图所示），每条路线被选择的概率是1/2；
2. 每次抖动操作的概率为1/2；
3. 每次抖动的参数都是随机生成的。

![](./2023-11-08-some-review-about-vision--2D-Object-Detection-Anchor-based-One-Stage-SSD/截屏2023-11-08 15.51.54.png)

**随机裁剪**

随机裁剪的操作过程如下图所示，需要注意的是对图像进行裁剪后，需要判断裁剪图像的标注框是否满足一定条件（标注框被裁部分的占比过大等），此处随机的含义是对图像进行随机裁剪的概率是1/2。

![](./2023-11-08-some-review-about-vision--2D-Object-Detection-Anchor-based-One-Stage-SSD/截屏2023-11-08 15.53.20.png)

**随机扩充**

随机裁剪的操作过程如下图所示，这里均值指的是训练图像的像素均值（已事先计算好），此处随机的含义也是对图像进行随机扩充的概率是1/2。

![](./2023-11-08-some-review-about-vision--2D-Object-Detection-Anchor-based-One-Stage-SSD/截屏2023-11-08 15.54.50.png)

**随机水平翻转**

以1/2的概率对图像进行随机水平翻转，随机水平翻转的过程如下图所示。

![](./2023-11-08-some-review-about-vision--2D-Object-Detection-Anchor-based-One-Stage-SSD/截屏2023-11-08 15.55.47.png)

 **缩放**

把任意大小的图像缩放到300x300大小（该步骤可能会改变物体的比例），得到输入图像。

需要注意的是，在随机裁剪、随机扩充、随机水平翻转和缩放过程中，随着图像的变化，标注框的位置也会随之发生变化，需要将标注框的位置进行相应的调整。

**基础网络**

![](./2023-11-08-some-review-about-vision--2D-Object-Detection-Anchor-based-One-Stage-SSD/截屏2023-11-08 15.56.59.png)

SSD的基础网络 = 全卷积版的VGG16 + 额外添加的卷积层

- - 全卷积版的VGG16：将VGG16中的全连接层FC6和FC7通过权重采样变成卷积层Conv6和Conv7
  - 额外添加的卷积层：额外添加了8个卷积层，每2个卷积层为1组，每组的下采样倍数相同，共下采样8/2=4次

由于采用的是预训练好的VGG16模型，在该模型中特征经过Conv4_3卷积层后输出的值较其他5个检测层输出的特征相比大特别多，因此使用归一化操作把该层输出的特征值限定为20（在神经网络学习过程中对该参数也会进行调整），如果不进行该操作在训练过程中很容易出现LOSS不收敛的情况。

### 多检测层

SSD中非常重要的一点是选取了6个检测层：Conv4_3、Conv_7、Conv8_2、Conv9_2、Conv10_2、Conv11_2。这些检测层的分辨率、感受野各不相同，**更低层的特征层由于感受野较小，可以关联小尺度的锚框，特征层的层数越高，感受野越大，关联锚框的尺度也就可以相应的增大**。这样铺设锚框的好处是可以让大、中、小不同尺度的锚框都具有较合理的铺设间隔，提升网络对不同尺度目标的检测能力。

各检测层的下采样倍数、铺设锚框大小、锚框比例、锚框数量以及检测层上的各点铺设的锚框数量如下表所示。

| 检测层       | Conv4_3     | Conv_7              | Conv8_2             | Conv9_2             | Conv10-2    | Conv11_2    |
| ------------ | ----------- | ------------------- | ------------------- | ------------------- | ----------- | ----------- |
| 下采样倍数   | 8           | 16                  | 32                  | 64                  | 128         | 256         |
| 特征大小     | 38×38       | 19×19               | 10×10               | 5×5                 | 3×3         | 1×1         |
| 锚框大小     | {30, 60}    | {60, 111}           | {111, 162}          | {162, 213}          | {213, 264}  | {264, 315}  |
| 锚框比例     | {0.5, 1, 2} | {1/3, 0.5, 1, 2, 3} | {1/3, 0.5, 1, 2, 3} | {1/3, 0.5, 1, 2, 3} | {0.5, 1, 2} | {0.5, 1, 2} |
| 单点锚框数量 | 4           | 6                   | 6                   | 6                   | 4           | 4           |

![](./2023-11-08-some-review-about-vision--2D-Object-Detection-Anchor-based-One-Stage-SSD/截屏2023-11-08 15.59.58.png)

将SSD所有检测层铺设的锚框进行汇总，可得到38×38×4+19×19×6+10×10×6+5×5×6+3×3×4+1×1×4=8732个锚框。

**难负样本挖掘**

在得到8732个锚框后，通过锚框匹配策略将锚框划分为正样本与负样本：真实标注框的最佳匹配或IOU≥0.5的锚框划分为正样本，IOU<0.5的锚框划分为负样本。此时一般只有几十个锚框是正样本，其他都是负样本，**正负样本比例极度失衡**（30个正样本/8700个负样本≈1/290），导致网络训练会朝着错误的方向优化（把所有的样本都分类为负样本就可以得到很高的分类精度）。为了解决正负样本比例失衡的问题，RPN和SSD都采取了相应的策略。

RPN的解决方案：正样本数量保持不变，随机选择一小部分负样本，忽略其他负样本；

SSD的解决方案：正样本保持不变，根据分类误差损失函数值的大小对负样本进行降序排列，损失函数值越大，说明该负样本对网络训练越有效果，选出损失函数值较大的那些负样本（选取数量为正样本数量的3倍），忽略其他负样本。

**算法总结**

SSD检测算法的主要贡献有两点：

1. 丰富的数据增广：RPN只是用了水平翻转和静态多尺度训练，而SSD设计了随机性更强、更丰富的数据增广，例如颜色抖动、随机裁剪扩充（动态多尺度训练）。打竞赛或者做实际工业项目的时候数据增广十分有用。
2. 多尺度的检测层：RPN是在单个检测层上关联锚框进行检测，而SSD在**多个不同尺度的检测层**上关联适当的锚框进行检测，后续算法基本都采用多检测层这种设计。

SSD是单阶段检测算法的集大成者，后续的单阶段检测算法大多都是基于SSD进行改进的，SSD在保持几十FPS的速度的同时，精度与多阶段检测算法差不多。且所有代码均是基于Caffe用C++实现，方便工程部署，很多实际产品的初期都是采用SSD算法进行目标检测。

